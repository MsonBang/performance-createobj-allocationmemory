## 对象创建
    类加载检查
    是否已经加载  否  需要加载  是 ，到下一步
    分配内存
    初始化
    设置对象头
    执行<init>方法
    
    1.类加载检查
        虚拟机遇到一条new指令时，首先先查这个指令参数是否能在常量池找到一个类的符号应用，并检查这个符号
        应用代表的类是否被加载解析和初始化过，如果没有，那么必须执行相应的类加载过程。
        
    2.分配内存
        类检查通过后，接下来虚拟机为新生对象分配内存。对象所需内存大小在类加载完便可以完全确定，为对象分配空间的任务，
        相当于从堆中划分出一个块儿内存。
        
        这样就有两个问题：
            如何划分内存？
            在并发情况下，正在给A对象分配内存，指针还没来得及修改，对象B又使用了原来指针分配的内存。
        
        （1）分配划分内存方法：
        
            指针碰撞（默认用指针碰撞）
                如果Java堆中的内存是完整的，所有用过的内存放到一遍，空闲的放到一边。中间放一个指针作为分界点。分配
                内存就是将中间指针向空闲那边挪动一段大小距离。
                
            空闲列表
                如果Java堆中的内存并不是完整的，已使用的和未使用的内存相互交错，那就不能用指针碰撞了
                虚拟机就必须维护一个列表，记录那些内存是可以用的。在分配的时候从列表中找到一块儿足够大的空间划分给对象。
                
        （2）解决并发问题的方法：
            CAS：
                虚拟机采用cas配上失败重试的方式保证更新操作原子性来对分配内存空间的动作进行同步处理。
            本地线程分配缓冲：
                把内存分配的动作按照线程划分不同的空间中执行。即每个线程在Java堆中预先分配一小块内存。
                通过 -Xx:+/-UserTLAB 参数来设定虚拟机是否使用这种方式（JVM默认开启）。-XX:TLABSize 指定TLAB大小。
                
    3.初始化
        内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
        这一步操作保证了对象的实例字段再Java代码中可以不用赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。
        
    4.设置对象头
        初始化零值以后，虚拟机要对对象进行设置。
        
    5.执行<init>方法
        执行init方法，对象按照编码意愿进行初始化，也就是我们说的赋值操作。和执行构造方法。
        
        对象大小与指针压缩：
        
            5.1 什么是指针压缩？
                1.jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩 
                2.jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针 
                3.启用指针压缩:­XX:+UseCompressedOops(默认开启)，禁止指针压缩:­XX:­UseCompressedOops
                
            5.2 为什么要进行指针压缩？ 
                1.在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时GC也会承受较大压力 
                
                2.为了减少64位平台下内存的消耗，启用指针压缩功能
                
                3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，
                  使得jvm 只用32位地址就可以支持更大的内存配置(小于等于32G) 
                
                4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间 
                
                5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，
                  所以堆内 存不要大于32G为好
                             
## 对象内存分配
    
    1.对象栈上分分配
        (1) 我们通过JVM内存分配可以知道Java中的对象都是在堆上进行分配。当对象没有被引用的时候，需要依靠GC进行回首内存，如果
            对象数量较多的时候，会给GC带来交大压力，也间接影响了性能。
        (2) 为了减少临时对象在堆内存分配的数量，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将对象在栈上分配内存。
            这样对象所占用的内存空间就随着栈祯出栈而销毁，减轻了垃圾回收的压力。
            
        1.1 对象逃逸分析
            就是分析对象动态作用域，当一个对象在方法中被定义后，他可能被外部方法所应用。
            public User test1() { 
                User user = new User(); 
                user.setId(1); 
                user.setName("zhuge"); 
                //TODO 保存到数据库
                return user; 
                }  
             
            public void test2() { 
                User user = new User(); 
                user.setId(1);
                user.setName("zhuge"); 
                //TODO 保存到数据库 
                }
            综上：很明显test1()方法中的user对象被返回了，这个对象的作用域范围不确定。
                test2()方法中的user对象我们可以确定当方法结束这个对象就是无效对象了，对于这样的我们其实可以在
                将其分配在栈内存中，让其跟着方法结束随着出栈而一起被回收掉。
                
        1.2 标量替换
            定义：
                通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解是，JVM不会创建该对象 ，而是将该对象成员变量
                分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈祯分配空间，这样就不会因为没有一大块连续
                空间导致对象内存分配不够分配。
                
    2.对象在Eden区分配
    
    3.大对象直接进入老年代
    
    4.长期存活的对象直接进入老年代
    
    5.对象动态年龄判断
    
    6.老年代空间分配担保机制
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
            